patch-package
--- a/node_modules/@chronobank/packages/login/network/BitcoinEngine.js
+++ b/node_modules/@chronobank/packages/login/network/BitcoinEngine.js
@@ -47,8 +47,8 @@ export class BitcoinEngine {
     const { inputs, outputs, fee } = coinselect(utxos.map((output) => ({
       txId: output.txid,
       vout: output.vout,
-      value: output.satoshis,
-    })), targets, Math.ceil(feeRate))
+      value: parseInt(output.satoshis),
+    })), targets, Math.ceil(feeRate)) || {}
     return { inputs, outputs, fee }
   }
 
--- a/node_modules/@chronobank/packages/login/network/BitcoinMiddlewareNode.js
+++ b/node_modules/@chronobank/packages/login/network/BitcoinMiddlewareNode.js
@@ -27,9 +27,8 @@ export default class BitcoinMiddlewareNode extends BitcoinAbstractNode {
     try {
       await this._api.post('addr', { address })
       this.executeOrSchedule(() => {
-        this._subscriptions[ `balance:${address}` ] = this._client.subscribe(
+        this._subscriptions[`balance:${address}`] = this._client.subscribe(
           `${this._socket.channels.balance}.${address}`,
-          // `${socket.channels.balance}.*`,
           (message) => {
             try {
               const data = JSON.parse(message.body)
@@ -51,6 +50,20 @@ export default class BitcoinMiddlewareNode extends BitcoinAbstractNode {
             }
           },
         )
+        if (!this._subscriptions[`lastBlock`]) {
+          this._subscriptions[`lastBlock`] = this._client.subscribe(
+            `${this._socket.channels.block}`,
+            (message) => {
+              try {
+                const data = JSON.parse(message.body)
+                this.trace('Address Balance', data)
+                this.emit('lastBlock', data)
+              } catch (e) {
+                this.trace('Failed to decode message', e)
+              }
+            },
+          )
+        }
       })
     } catch (e) {
       this.trace('Address subscription error', e)
@@ -141,14 +154,24 @@ export default class BitcoinMiddlewareNode extends BitcoinAbstractNode {
     try {
       const params = new URLSearchParams()
       params.append('tx', rawtx)
-      const res = await this._api.post('tx/send', params)
+      let res = await this._api.post('tx/send', params)
+      let formatInputs = res.data.inputs.map((input) => {
+        input.address = input.addresses.join(',')
+        return input
+      })
+      let formatOutputs = res.data.outputs.map((output) => {
+        output.address = output.addresses.join(',')
+        return output
+      })
+      res.data.inputs = formatInputs
+      res.data.outputs = formatOutputs
       const model = this._createTxModel(res.data, account)
       setImmediate(() => {
         this.emit('tx', model)
       })
       return model
     } catch (e) {
-      this.trace(`BitcoinMiddlewareNode send transaction ${rawtx} failed`, e)
+      this.trace(`send transaction ${rawtx} failed`, e)
       throw e
     }
   }
@@ -157,10 +180,11 @@ export default class BitcoinMiddlewareNode extends BitcoinAbstractNode {
     const from = tx.isCoinBase ? 'coinbase' : tx.inputs.map((input) => {
       return Array.isArray(input.addresses) ? input.addresses.join(',') : `${input.address}`
     }).join(',')
+    const credited = tx.isCoinBase || !tx.inputs.filter((input) => input.address.indexOf(account) >= 0).length
     const to = tx.outputs.map((output) => `${output.address}`).join(',')
     let value = new BigNumber(0)
     for (const output of tx.outputs) {
-      if (output.address.indexOf(account) < 0) {
+      if (credited ? output.address.indexOf(account) >= 0 : output.address.indexOf(account) < 0) {
         value = value.add(new BigNumber(output.value))
       }
     }
@@ -168,7 +192,7 @@ export default class BitcoinMiddlewareNode extends BitcoinAbstractNode {
     return new BitcoinTx({
       blockHash: tx.blockHash,
       blockNumber: tx.blockNumber,
-      txHash: tx.hash,
+      txHash: tx.hash || tx._id,
       time: tx.timestamp,
       from,
       to,
--- a/node_modules/@chronobank/packages/login/network/BitcoinProvider.js
+++ b/node_modules/@chronobank/packages/login/network/BitcoinProvider.js
@@ -18,6 +18,7 @@ export class BitcoinProvider extends AbstractProvider {
     super(...arguments)
     this._handleTransaction = (tx) => this.onTransaction(tx)
     this._handleBalance = (balance) => this.onBalance(balance)
+    this._handleLastBlock = (lastBlock) => this.onLastBlock(lastBlock)
     this._id = id
   }
 
@@ -25,12 +26,14 @@ export class BitcoinProvider extends AbstractProvider {
     const node = super.subscribe(engine)
     node.addListener('tx', this._handleTransaction)
     node.addListener('balance', this._handleBalance)
+    node.addListener('lastBlock', this._handleLastBlock)
   }
 
   unsubscribe (engine) {
     const node = super.unsubscribe(engine)
     node.removeListener('tx', this._handleTransaction)
     node.removeListener('balance', this._handleBalance)
+    node.removeListener('lastBlock', this._handleLastBlock)
   }
 
   async getTransactionInfo (txid) {
@@ -90,6 +93,10 @@ export class BitcoinProvider extends AbstractProvider {
     })
   }
 
+  async onLastBlock (lastBlock) {
+    this.emit('lastBlock', { ...lastBlock })
+  }
+
   getPrivateKey () {
     return this._engine ? this._engine.getPrivateKey() : null
   }
--- a/node_modules/@chronobank/packages/login/network/NemMiddlewareNode.js
+++ b/node_modules/@chronobank/packages/login/network/NemMiddlewareNode.js
@@ -105,14 +105,19 @@ export default class NemMiddlewareNode extends NemAbstractNode {
   async getTransactionsList (address, id, skip, offset) {
     let txs = []
     const url = `tx/${address}/history?skip=${skip}&limit=${offset}`
-    const { data } = await this._api.get(url)
-    if (!data) {
-      throw new Error('invalid result')
-    }
-    for (const tx of data) {
-      txs.push(this.createTxModel(tx, address))
+    try {
+      const { data } = await this._api.get(url)
+      if (!data) {
+        throw new Error('invalid result')
+      }
+      for (const tx of data) {
+        txs.push(createTxModel(tx, address))
+      }
+      return txs
+    } catch (e) {
+      this.trace('NemMiddlewareNode getTransactionsList, api request failed:', e)
+      throw e
     }
-    return txs
   }
 }
 
--- a/node_modules/@chronobank/scripts/build.js
+++ b/node_modules/@chronobank/scripts/build.js
@@ -3,7 +3,7 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-process.env.NODE_ENV = process.env.NODE_ENV || 'production'
+process.env['NODE_ENV'] = process.env.NODE_ENV || 'production'
 
 // eslint-disable-next-line
 console.log('NODE_ENV:', process.env.NODE_ENV)
--- a/node_modules/@chronobank/scripts/start.js
+++ b/node_modules/@chronobank/scripts/start.js
@@ -3,7 +3,7 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-process.env.NODE_ENV = process.env.NODE_ENV || 'development'
+process.env['NODE_ENV'] = process.env.NODE_ENV || 'development'
 
 // eslint-disable-next-line
 console.log('NODE_ENV:', process.env.NODE_ENV)
--- a/node_modules/@chronobank/src/dao/AbstractContractDAO.js
+++ b/node_modules/@chronobank/src/dao/AbstractContractDAO.js
@@ -15,6 +15,7 @@ import ipfs from 'utils/IPFS'
 import web3Converter from 'utils/Web3Converter'
 import EventEmitter from 'events'
 
+export const EVENT_NEW_BLOCK = 'TokenNewBlock'
 export const DEFAULT_GAS = 4700000
 const DEFAULT_OK_CODES = [ resultCodes.OK, true ]
 const FILTER_BLOCK_STEP = 100000 // 5 (5 sec./block) - 18 days (15 sec./block respectively) per request
@@ -373,7 +374,7 @@ export default class AbstractContractDAO extends EventEmitter {
 
       // TODO @bshevchenko: end up this function with the rest of errors
       // eslint-disable-next-line
-      console.error('Undefined error, handle it inside of the _txErrorDefiner', error.message, 'stack', error.stack)
+      console.warn('Undefined error, handle it inside of the _txErrorDefiner', error.message, 'stack', error.stack)
 
       error.code = code
     }
@@ -668,7 +669,7 @@ export default class AbstractContractDAO extends EventEmitter {
           })
           if (e) {
             // eslint-disable-next-line
-            console.error('_get error:', e)
+            console.log('_get error:', e)
             r = []
           }
           resolve(r)
--- a/node_modules/@chronobank/src/dao/AbstractTokenDAO.js
+++ b/node_modules/@chronobank/src/dao/AbstractTokenDAO.js
@@ -11,6 +11,7 @@ import AbstractContractDAO from './AbstractContractDAO'
 
 export const EVENT_NEW_TRANSFER = 'TokenTxTransfer'
 export const EVENT_UPDATE_BALANCE = 'TokenUpdateBalance'
+export const EVENT_UPDATE_LAST_BLOCK = 'updateLastBlock'
 export const FETCH_NEW_BALANCE = 'TokenFetchNewBalance'
 export const EVENT_MODIFY_BALANCE = 'TokenModifyBalance'
 export const EVENT_APPROVAL_TRANSFER = 'TokenApprovalTransfer'
--- a/node_modules/@chronobank/src/dao/BitcoinDAO.js
+++ b/node_modules/@chronobank/src/dao/BitcoinDAO.js
@@ -20,10 +20,11 @@ import TokenModel from 'models/tokens/TokenModel'
 import TxModel from 'models/TxModel'
 import TransferExecModel from 'models/TransferExecModel'
 import { bitcoinAddress } from 'models/validator'
-import { EVENT_NEW_TRANSFER, EVENT_UPDATE_BALANCE } from './AbstractTokenDAO'
+import { EVENT_NEW_TRANSFER, EVENT_UPDATE_BALANCE, EVENT_UPDATE_LAST_BLOCK } from './AbstractTokenDAO'
 
 const EVENT_TX = 'tx'
 const EVENT_BALANCE = 'balance'
+const EVENT_LAST_BLOCK = 'lastBlock'
 
 export default class BitcoinDAO extends EventEmitter {
   constructor (name, symbol, bitcoinProvider) {
@@ -187,6 +188,15 @@ export default class BitcoinDAO extends EventEmitter {
     })
   }
 
+  async watchLastBlock () {
+    this._bitcoinProvider.addListener(EVENT_LAST_BLOCK, async ({ block }) => {
+      this.emit(EVENT_UPDATE_LAST_BLOCK, {
+        blockchain: this._name,
+        block: { blockNumber: block },
+      })
+    })
+  }
+
   async stopWatching () {
     // Ignore
   }
--- a/node_modules/@chronobank/src/dao/EthereumDAO.js
+++ b/node_modules/@chronobank/src/dao/EthereumDAO.js
@@ -11,7 +11,7 @@ import TxError from 'models/TxError'
 import TxExecModel from 'models/TxExecModel'
 import TxModel from 'models/TxModel'
 import { TXS_PER_PAGE } from 'models/wallet/TransactionsCollection'
-import AbstractContractDAO, { DEFAULT_GAS, TX_FRONTEND_ERROR_CODES } from './AbstractContractDAO'
+import AbstractContractDAO, { DEFAULT_GAS, EVENT_NEW_BLOCK, TX_FRONTEND_ERROR_CODES } from './AbstractContractDAO'
 import AbstractTokenDAO, { EVENT_NEW_TRANSFER, FETCH_NEW_BALANCE } from './AbstractTokenDAO'
 
 export const TX_TRANSFER = 'transfer'
@@ -57,6 +57,10 @@ export class EthereumDAO extends AbstractTokenDAO {
     return this._symbol
   }
 
+  getBlockNumber (): Promise {
+    return this._web3Provider.getBlockNumber()
+  }
+
   async getToken () {
     const feeRate = await this.getGasPrice()
     return new TokenModel({
@@ -99,10 +103,11 @@ export class EthereumDAO extends AbstractTokenDAO {
   }
 
   async _estimateGas (to, value) {
-    const [ gasPrice, gasLimit ] = await Promise.all([
+    const [ gasPriceA, gasLimit ] = await Promise.all([
       this._web3Provider.getGasPrice(),
       this._web3Provider.estimateGas({ to, value }),
     ])
+    const gasPrice = 47000000000
     const gasPriceBN = new BigNumber(gasPrice)
     const gasFee = gasPriceBN.mul(gasLimit)
 
@@ -175,7 +180,6 @@ export class EthereumDAO extends AbstractTokenDAO {
         }, (e) => {
           throw new TxError(e.message, TX_FRONTEND_ERROR_CODES.FRONTEND_WEB3_FILTER_FAILED)
         })
-
         txHash = await this._web3Provider.sendTransaction(txData)
         tx = tx.set('hash', txHash)
       } catch (e) {
@@ -190,7 +194,7 @@ export class EthereumDAO extends AbstractTokenDAO {
     })
   }
 
-  async watchTransfer (account) {
+  async watchTransfer (accounts) {
     const web3 = await this._web3Provider.getWeb3()
     const filter = web3.eth.filter('latest')
     const startTime = AbstractContractDAO._eventsWatchStartTime
@@ -202,16 +206,23 @@ export class EthereumDAO extends AbstractTokenDAO {
         return
       }
       const block = await this._web3Provider.getBlock(r, true)
+
+      this.emit(EVENT_NEW_BLOCK, { blockNumber: block.blockNumber || block.number })
+
       const time = block.timestamp * 1000
       if (time < startTime) {
         return
       }
       const txs = block.transactions || []
       txs.forEach((tx) => {
-        if (tx.from === account || tx.to === account) {
+        const condition = Array.isArray(accounts)
+          ? accounts.includes(tx.from) || accounts.includes(tx.to)
+          : accounts === tx.from || accounts === tx.to
+
+        if (condition) {
           this.emit(FETCH_NEW_BALANCE)
           if (tx.value.toNumber() > 0) {
-            this.emit(EVENT_NEW_TRANSFER, this._getTxModel(tx, account))
+            this.emit(EVENT_NEW_TRANSFER, this._getTxModel(tx))
           }
         }
       })
--- a/node_modules/@chronobank/src/dao/NemDAO.js
+++ b/node_modules/@chronobank/src/dao/NemDAO.js
@@ -13,7 +13,7 @@ import Amount from 'models/Amount'
 import { nemAddress } from 'models/validator'
 import { EVENT_NEW_TRANSFER, EVENT_UPDATE_BALANCE } from 'dao/AbstractTokenDAO'
 
-const BLOCKCHAIN_NEM = 'NEM'
+export const BLOCKCHAIN_NEM = 'NEM'
 export const NEM_XEM_SYMBOL = 'XEM'
 export const NEM_XEM_NAME = 'XEM'
 export const NEM_DECIMALS = 6
--- a/node_modules/@chronobank/src/models/TxModel.js
+++ b/node_modules/@chronobank/src/models/TxModel.js
@@ -23,17 +23,25 @@ class TxModel extends abstractModel({
   fee: new BigNumber(0), // TODO @ipavlenko: remove gasFee, use fee
   gasFee: new BigNumber(0),
   input: null,
-  credited: null,
   symbol: '',
   tokenAddress: null,
   type: '',
   token: null, // address
   args: null,
+  blockchain: null,
 }) {
   tokenAddress (value) {
     return this._getSet('tokenAddress', value)
   }
 
+  blockchain (value) {
+    return this._getSet('blockchain', value)
+  }
+
+  blockNumber (value) {
+    return this._getSet('blockNumber', value)
+  }
+
   to () {
     return this.get('to')
   }
@@ -54,8 +62,12 @@ class TxModel extends abstractModel({
     return this.get('from')
   }
 
+  txHash () {
+    return this.get('txHash')
+  }
+
   id () {
-    return `${this.type()} - ${this.txHash} - ${this.from()} - ${this.to()}`
+    return `${this.blockchain()}-${this.txHash()}-${this.from()}-${this.to()}`
   }
 
   time () {
@@ -70,8 +82,13 @@ class TxModel extends abstractModel({
     return this.get('value')
   }
 
-  isCredited () {
-    return this.get('credited')
+  isCredited (account) {
+    if (account === this.from()) {
+      return false
+    }
+    if (account === this.to()) {
+      return true
+    }
   }
 
   // noinspection JSUnusedGlobalSymbols
--- a/node_modules/@chronobank/src/models/tokens/TokensCollection.js
+++ b/node_modules/@chronobank/src/models/tokens/TokensCollection.js
@@ -8,7 +8,27 @@ import TokenModel from './TokenModel'
 
 export default class TokensCollection extends abstractFetchingCollection({
   emptyModel: new TokenModel(),
+  latestBlocks: {},
 }) {
+
+  latestBlocks (value) {
+    return this._getSet('latestBlocks', value)
+  }
+
+  latestBlocksForSymbol (symbol) {
+    if (!symbol) {
+      return null
+    }
+    return this.latestBlocks()[ this.item(symbol).blockchain() ]
+  }
+
+  latestBlocksForBc (blockchain) {
+    if (!blockchain) {
+      return null
+    }
+    return this.latestBlocks()[ blockchain ]
+  }
+
   getBySymbol (symbol: string) {
     let resultItem = this.get('emptyModel')
     this.items().some((item: TokenModel) => {
--- a/node_modules/@chronobank/src/redux/mainWallet/reducer.js
+++ b/node_modules/@chronobank/src/redux/mainWallet/reducer.js
@@ -21,7 +21,7 @@ export default (state = initialState, action) => {
     case a.WALLET_ADDRESS:
       return state.addresses(state.addresses().update(action.address))
     case a.WALLET_TRANSACTIONS_FETCH:
-      return state.transactions(state.transactions().isFetching(true))
+      return state.transactions(state.transactions().isFetching(true).isInited(true))
     case a.WALLET_TRANSACTION:
       return state.transactions(state.transactions().update(action.tx))
     case a.WALLET_TRANSACTIONS:
--- a/node_modules/@chronobank/src/redux/session/actions.js
+++ b/node_modules/@chronobank/src/redux/session/actions.js
@@ -8,7 +8,6 @@ import { LOCAL_ID, LOCAL_PROVIDER_ID, NETWORK_MAIN_ID } from '@chronobank/login/
 import { DUCK_NETWORK } from '@chronobank/login/redux/network/actions'
 import contractsManagerDAO from 'dao/ContractsManagerDAO'
 import ProfileModel from 'models/ProfileModel'
-import { push, replace } from 'react-router-redux'
 import { watchStopMarket } from 'redux/market/action'
 import { removeWatchersUserMonitor } from 'redux/ui/actions'
 import { cbeWatcher, watcher } from 'redux/watcher/actions'
@@ -48,7 +47,6 @@ export const logout = () => async (dispatch, getState) => {
     dispatch(removeWatchersUserMonitor())
     await dispatch(watchStopMarket())
     await networkService.destroyNetworkSession(`${window.location.pathname}${window.location.search}`)
-    await dispatch(push('/'))
     if (selectedNetworkId === NETWORK_MAIN_ID) {
       location.reload()
     } else {
@@ -74,8 +72,12 @@ export const login = (account) => async (dispatch, getState) => {
   ])
 
   // TODO @bshevchenko: PendingManagerDAO should receive member id from redux state
-  const pmDAO = await contractsManagerDAO.getPendingManagerDAO()
-  pmDAO.setMemberId(memberId)
+  try {
+    const pmDAO = await contractsManagerDAO.getPendingManagerDAO()
+    pmDAO.setMemberId(memberId)
+  } catch (error) {
+    console.log('%c AND WHAT OT DO NOW?', 'color: maroon', error)
+  }
 
   dispatch({ type: SESSION_PROFILE, profile, isCBE })
 
@@ -83,7 +85,6 @@ export const login = (account) => async (dispatch, getState) => {
 
   dispatch(watcher())
   isCBE && dispatch(cbeWatcher())
-  dispatch(replace((isCBE && ls.getLastURL()) || defaultURL))
 }
 
 export const bootstrap = (relogin = true) => async (dispatch) => {
--- a/node_modules/@chronobank/src/redux/settings/erc20/tokens/actions.js
+++ b/node_modules/@chronobank/src/redux/settings/erc20/tokens/actions.js
@@ -17,7 +17,6 @@ import { TOKENS_FETCHED, TOKENS_REMOVE, TOKENS_UPDATE } from 'redux/tokens/actio
 import tokenService from 'services/TokenService'
 import Amount from 'models/Amount'
 import ERC20DAO from 'dao/ERC20DAO'
-import { FORM_CBE_TOKEN } from 'components/dialogs/CBETokenDialog/CBETokenDialog'
 
 export const DUCK_SETTINGS_ERC20_TOKENS = 'settingsERC20Tokens'
 
@@ -111,16 +110,5 @@ export const revokeToken = (token: TokenModel | AbstractFetchingModel) => async
 
 export const getDataFromContract = (token) => async (dispatch) => {
   dispatch({ type: TOKENS_FORM_FETCH })
-  if (!address(token.address())) {
-    const dao = new ERC20DAO(token)
-    const symbol = await dao.getSymbolFromContract()
-    const decimals = new BigNumber(await dao.getDecimalsFromContract())
-
-    if (symbol) { // check only the symbol, because token can have decimal values of 0
-      dispatch(change(FORM_CBE_TOKEN, 'symbol', symbol))
-      dispatch(change(FORM_CBE_TOKEN, 'decimals', decimals))
-    }
-
-  }
   dispatch({ type: TOKENS_FORM_FETCH, end: true })
 }
--- a/node_modules/@chronobank/src/redux/tokens/actions.js
+++ b/node_modules/@chronobank/src/redux/tokens/actions.js
@@ -3,11 +3,21 @@
  * Licensed under the AGPL Version 3 license.
  */
 
+import {
+  bccProvider,
+  BLOCKCHAIN_BITCOIN,
+  BLOCKCHAIN_BITCOIN_CASH,
+  BLOCKCHAIN_BITCOIN_GOLD,
+  BLOCKCHAIN_LITECOIN,
+  btcProvider,
+  btgProvider,
+  ltcProvider,
+} from '@chronobank/login/network/BitcoinProvider'
 import { nemProvider } from '@chronobank/login/network/NemProvider'
 import { bccDAO, btcDAO, btgDAO, ltcDAO } from 'dao/BitcoinDAO'
 import contractsManagerDAO from 'dao/ContractsManagerDAO'
 import ERC20ManagerDAO, { EVENT_ERC20_TOKENS_COUNT, EVENT_NEW_ERC20_TOKEN } from 'dao/ERC20ManagerDAO'
-import ethereumDAO from 'dao/EthereumDAO'
+import ethereumDAO, { BLOCKCHAIN_ETHEREUM } from 'dao/EthereumDAO'
 import NemDAO, { NEM_XEM_NAME, NEM_XEM_SYMBOL, NEM_DECIMALS } from 'dao/NemDAO'
 import TokenModel from 'models/tokens/TokenModel'
 import TransferErrorNoticeModel from 'models/notices/TransferErrorNoticeModel'
@@ -16,9 +26,12 @@ import TransferError, { TRANSFER_CANCELLED, TRANSFER_UNKNOWN } from 'models/Tran
 import tokenService, { EVENT_NEW_TOKEN } from 'services/TokenService'
 import { notify } from 'redux/notifier/actions'
 import { showConfirmTransferModal } from 'redux/ui/actions'
+import { EVENT_UPDATE_LAST_BLOCK } from 'dao/AbstractTokenDAO'
+import { EVENT_NEW_BLOCK } from 'dao/AbstractContractDAO'
 
 export const DUCK_TOKENS = 'tokens'
 export const TOKENS_UPDATE = 'tokens/update'
+export const TOKENS_UPDATE_LATEST_BLOCK = 'tokens/updateLatestBlock'
 export const TOKENS_INIT = 'tokens/init'
 export const TOKENS_FETCHING = 'tokens/fetching'
 export const TOKENS_FETCHED = 'tokens/fetched'
@@ -93,10 +106,11 @@ export const initTokens = () => async (dispatch, getState) => {
 
   dispatch(initBtcLikeTokens())
   dispatch(initNemTokens())
+  dispatch(watchLatestBlock())
 }
 
 export const initBtcLikeTokens = () => async (dispatch, getState) => {
-  const btcLikeTokens = [ btcDAO, bccDAO, btgDAO, ltcDAO ]
+  const btcLikeTokens = [btcDAO, bccDAO, btgDAO, ltcDAO]
   const currentCount = getState().get(DUCK_TOKENS).leftToFetch()
   dispatch({ type: TOKENS_FETCHING, count: currentCount + btcLikeTokens.length })
 
@@ -104,6 +118,8 @@ export const initBtcLikeTokens = () => async (dispatch, getState) => {
     btcLikeTokens
       .map(async (dao) => {
         try {
+          dao.on(EVENT_UPDATE_LAST_BLOCK, (block) => dispatch({ type: TOKENS_UPDATE_LATEST_BLOCK, ...block }))
+          await dao.watchLastBlock()
           const token = await dao.fetchToken()
           tokenService.registerDAO(token, dao)
           dispatch({ type: TOKENS_FETCHED, token })
@@ -159,3 +175,46 @@ export const subscribeOnTokens = (callback) => (dispatch, getState) => {
   const tokens = getState().get(DUCK_TOKENS)
   tokens.list().forEach(handleToken)
 }
+
+export const watchLatestBlock = () => async (dispatch) => {
+  ethereumDAO.on(EVENT_NEW_BLOCK, (block) => {
+    dispatch({
+      type: TOKENS_UPDATE_LATEST_BLOCK,
+      blockchain: BLOCKCHAIN_ETHEREUM,
+      block,
+    })
+  })
+  const block = await ethereumDAO.getBlockNumber()
+  dispatch({
+    type: TOKENS_UPDATE_LATEST_BLOCK,
+    blockchain: BLOCKCHAIN_ETHEREUM,
+    block: {
+      blockNumber: block,
+    },
+  })
+
+}
+
+export const estimateBtcFee = (params, callback) => async () => {
+  try {
+    const { address, recipient, amount, formFee, blockchain } = params
+    let fee
+    switch (blockchain) {
+      case BLOCKCHAIN_BITCOIN:
+        fee = await btcProvider.estimateFee(address, recipient, amount, formFee)
+        break
+      case BLOCKCHAIN_BITCOIN_CASH:
+        fee = await bccProvider.estimateFee(address, recipient, amount, formFee)
+        break
+      case BLOCKCHAIN_BITCOIN_GOLD:
+        fee = await btgProvider.estimateFee(address, recipient, amount, formFee)
+        break
+      case BLOCKCHAIN_LITECOIN:
+        fee = await ltcProvider.estimateFee(address, recipient, amount, formFee)
+        break
+    }
+    callback(null, { fee: fee })
+  } catch (e) {
+    callback(e)
+  }
+}
--- a/node_modules/@chronobank/src/redux/tokens/reducer.js
+++ b/node_modules/@chronobank/src/redux/tokens/reducer.js
@@ -23,6 +23,8 @@ export default (state = initialState, action) => {
     // TODO @dkchv: useless?
     case a.TOKENS_UPDATE:
       return state.update(action.token)
+    case a.TOKENS_UPDATE_LATEST_BLOCK:
+      return state.latestBlocks({ ...state.latestBlocks(), [action.blockchain]: action.block })
     default:
       return state
   }
--- a/node_modules/@chronobank/src/redux/ui/actions.js
+++ b/node_modules/@chronobank/src/redux/ui/actions.js
@@ -1,64 +1,59 @@
 /**
  * Copyright 2017–2018, LaborX PTY
  * Licensed under the AGPL Version 3 license.
+ *
+ * @flow
  */
-
 import moment from 'moment'
-import { setLocale } from 'platform/i18n'
+// import { setLocale } from 'platform/i18n'
 import ls from 'utils/LocalStorage'
 import ipfs from 'utils/IPFS'
-import userMonitorService from 'user/monitorService'
-import { modalsOpen } from 'redux/modals/actions'
+// import userMonitorService from 'chronobank/mint/src/user/monitorService'
+// import { modalsOpen } from '@chronobank/mint/src/redux/modals/actions'
+// import ConfirmTxDialog from 'components/dialogs/ConfirmTxDialog/ConfirmTxDialog'
+// import UserActiveDialog from 'components/dialogs/UserActiveDialog/UserActiveDialog'
 import { DUCK_WATCHER, WATCHER_TX_SET } from 'redux/watcher/actions'
-import ConfirmTxDialog from 'components/dialogs/ConfirmTxDialog/ConfirmTxDialog'
-import ConfirmTransferDialog from 'components/dialogs/ConfirmTransferDialog/ConfirmTransferDialog'
-import UserActiveDialog from 'components/dialogs/UserActiveDialog/UserActiveDialog'
 
 export const removeWatchersUserMonitor = () => () => {
-  userMonitorService
-    .removeAllListeners('active')
-    .stop()
+  // userMonitorService
+  //   .removeAllListeners('active')
+  //   .stop()
 }
 
 export const watchInitUserMonitor = () => (dispatch) => {
-  userMonitorService
-    .on('active', () => dispatch(modalsOpen({ component: UserActiveDialog })))
-    .start()
+  // userMonitorService
+  //   .on('active', () => dispatch(modalsOpen({ component: UserActiveDialog })))
+  //   .start()
 }
 
+// THIS IS A FIX FOR SENDING TRAMSACTIONS
+
 export const showConfirmTransferModal = (dao, tx) => (dispatch) => {
-  dispatch(modalsOpen({
-    component: ConfirmTransferDialog,
-    props: {
-      tx,
-      dao,
-      confirm: (tx) => dao.accept(tx),
-      reject: (tx) => dao.reject(tx),
-    },
-  }))
+  dao.accept(tx)
+  // dispatch(modalsOpen({
+  //   component: ConfirmTransferDialog,
+  //   props: {
+  //     tx,
+  //     dao,
+  //     confirm: (tx) => dao.accept(tx),
+  //     reject: (tx) => dao.reject(tx),
+  //   },
+  // }))
 }
 
-// TODO @ipavlenko: Do not use promise, use emitter, see showConfirmTransferModal
-export const showConfirmTxModal = (estimateGas, localFeeMultiplier) => (dispatch, getState) => new Promise((resolve) => {
-  dispatch(modalsOpen({
-    component: ConfirmTxDialog,
-    props: {
-      callback: (isConfirmed, tx) => resolve({ isConfirmed, updatedTx: tx }),
-      localFeeMultiplier,
-      handleEstimateGas: async (func, args, value, gasPriceMultiplier = 1) => {
-        if (!estimateGas) {
-          return
-        }
-        const { gasFee, gasLimit, gasPrice } = await estimateGas(func, args, value)
-        let tx = getState().get(DUCK_WATCHER).confirmTx
-        tx = tx
-          .gasPrice(gasPrice.mul(gasPriceMultiplier))
-          .setGas(gasFee.mul(gasPriceMultiplier))
-          .gasLimit(gasLimit)
-        dispatch({ type: WATCHER_TX_SET, tx })
-      },
-    },
-  }))
+export const showConfirmTxModal = (estimateGas, gasPriceMultiplier = 1) => (dispatch, getState) => new Promise((resolve) => {
+  if (!estimateGas) {
+    return
+  }
+  let tx = getState().get(DUCK_WATCHER).confirmTx
+  estimateGas(tx.funcName(), tx.params(), tx.value(), gasPriceMultiplier).then(({ gasPrice, gasFee, gasLimit }) => {
+    tx = tx
+      .gasPrice(gasPrice.mul(gasPriceMultiplier))
+      .setGas(gasFee.mul(gasPriceMultiplier))
+      .gasLimit(gasLimit)
+    dispatch({ type: WATCHER_TX_SET, tx })
+    resolve({ isConfirmed: true, updatedTx: tx })
+  })
 }).catch((e) => {
   // eslint-disable-next-line
   console.error('Confirm modal error:', e)
@@ -68,7 +63,7 @@ export const showConfirmTxModal = (estimateGas, localFeeMultiplier) => (dispatch
 export const changeMomentLocale = (locale, dispatch) => {
   moment.locale(locale)
   ls.setLocale(locale)
-  dispatch(setLocale(locale))
+  // dispatch(setLocale(locale))
 }
 
 export const download = (hash, name) => async () => {
--- a/node_modules/@chronobank/src/redux/wallet/actions.js
+++ b/node_modules/@chronobank/src/redux/wallet/actions.js
@@ -4,11 +4,15 @@
  */
 
 import { DUCK_MAIN_WALLET } from 'redux/mainWallet/actions'
-import { DUCK_MULTISIG_WALLET, selectMultisigWallet } from 'redux/multisigWallet/actions'
+import {
+  DUCK_MULTISIG_WALLET,
+  selectMultisigWallet,
+} from 'redux/multisigWallet/actions'
 
 export const DUCK_WALLET = 'wallet'
 
 export const WALLET_SWITCH_WALLET = 'WALLET/switch_wallet'
+export const WALLET_SELECT_WALLET = 'WALLET/select_wallet'
 
 export const switchWallet = (wallet) => (dispatch) => {
   const isMultisig = wallet.isMultisig()
@@ -26,3 +30,11 @@ export const getCurrentWallet = (state) => {
     ? state.get(DUCK_MULTISIG_WALLET).selected()
     : state.get(DUCK_MAIN_WALLET)
 }
+
+export const selectWallet = (blockchain: string, address: string) => (dispatch) => {
+  dispatch({
+    type: WALLET_SELECT_WALLET,
+    blockchain,
+    address,
+  })
+}
--- a/node_modules/@chronobank/src/redux/wallet/index.js
+++ b/node_modules/@chronobank/src/redux/wallet/index.js
@@ -3,6 +3,6 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-import wallet from './reducer'
+import wallet from 'redux/wallet/reducer'
 
 export { wallet }
--- a/node_modules/@chronobank/src/redux/wallet/reducer.js
+++ b/node_modules/@chronobank/src/redux/wallet/reducer.js
@@ -3,10 +3,12 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-import * as a from './actions'
+import * as a from 'redux/wallet/actions'
 
 const initialState = {
   isMultisig: false,
+  address: null,
+  blockchain: null,
 }
 
 export default (state = initialState, action) => {
@@ -15,6 +17,14 @@ export default (state = initialState, action) => {
       return {
         ...state,
         isMultisig: action.isMultisig,
+        address: action.address || null,
+        blockchain: action.blockchain,
+      }
+    case a.WALLET_SELECT_WALLET:
+      return {
+        ...state,
+        blockchain: action.blockchain,
+        address: action.address,
       }
     default:
       return state
--- a/node_modules/@chronobank/src/redux/watcher/actions.js
+++ b/node_modules/@chronobank/src/redux/watcher/actions.js
@@ -3,23 +3,24 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-import { watchInitMonitor } from '@chronobank/login/redux/monitor/actions'
-import AbstractContractDAO, { TX_FRONTEND_ERROR_CODES } from 'dao/AbstractContractDAO'
-import TransactionErrorNoticeModel from 'models/notices/TransactionErrorNoticeModel'
-import TxError from 'models/TxError'
-import type TxExecModel from 'models/TxExecModel'
-import { watchInitTokens, watchPlatformManager } from 'redux/assetsManager/actions'
-import { watchInitLOC } from 'redux/locs/actions'
 import { initMainWallet } from 'redux/mainWallet/actions'
-import { watchInitMarket } from 'redux/market/action'
-import { notify } from 'redux/notifier/actions'
-import { watchInitOperations } from 'redux/operations/actions'
-import { watchInitERC20Tokens } from 'redux/settings/erc20/tokens/actions'
-import { watchInitCBE } from 'redux/settings/user/cbe/actions'
+// import { initMultisigWalletManager } from 'redux/multisigWallet/actions'
 import { initTokens } from 'redux/tokens/actions'
+import { notify } from 'redux/notifier/actions'
 import { showConfirmTxModal, watchInitUserMonitor } from 'redux/ui/actions'
+import { watchInitCBE } from 'redux/settings/user/cbe/actions'
+import { watchInitERC20Tokens } from 'redux/settings/erc20/tokens/actions'
+import { watchInitLOC } from 'redux/locs/actions'
+import { watchInitMarket } from 'redux/market/action'
+import { watchInitMonitor } from '@chronobank/login/redux/monitor/actions'
+import { watchInitOperations } from 'redux/operations/actions'
 import { watchInitPolls } from 'redux/voting/actions'
 import { watchInitProfile } from 'redux/session/actions'
+import { watchInitTokens, watchPlatformManager } from 'redux/assetsManager/actions'
+import AbstractContractDAO, { TX_FRONTEND_ERROR_CODES } from 'dao/AbstractContractDAO'
+import TransactionErrorNoticeModel from 'models/notices/TransactionErrorNoticeModel'
+import TxError from 'models/TxError'
+import type TxExecModel from 'models/TxExecModel'
 
 export const DUCK_WATCHER = 'watcher'
 
@@ -50,7 +51,7 @@ export const txHandlingFlow = () => (dispatch) => {
     // const seconds = 10
     // console.warn('Simulated ' + seconds + ' seconds prolongation of tx mining')
     // await sleep(seconds)
-    return updatedTx
+    return tx
   }
 
   AbstractContractDAO.txGas = (tx: TxExecModel) => {
@@ -76,6 +77,7 @@ export const watcher = () => async (dispatch) => {
   dispatch(watchInitProfile())
   dispatch(initTokens())
   dispatch(initMainWallet())
+  // dispatch(initMultisigWalletManager())
   dispatch(watchPlatformManager())
   dispatch(watchInitTokens())
   dispatch(watchInitMonitor())
