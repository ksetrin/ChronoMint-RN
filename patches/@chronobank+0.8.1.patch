patch-package
--- a/node_modules/@chronobank/packages/login/network/NemMiddlewareNode.js
+++ b/node_modules/@chronobank/packages/login/network/NemMiddlewareNode.js
@@ -110,7 +110,7 @@ export default class NemMiddlewareNode extends NemAbstractNode {
       throw new Error('invalid result')
     }
     for (const tx of data) {
-      txs.push(this.createTxModel(tx, address))
+      txs.push(createTxModel(tx, address))
     }
     return txs
   }
--- a/node_modules/@chronobank/src/redux/session/actions.js
+++ b/node_modules/@chronobank/src/redux/session/actions.js
@@ -8,7 +8,6 @@ import { LOCAL_ID, LOCAL_PROVIDER_ID, NETWORK_MAIN_ID } from '@chronobank/login/
 import { DUCK_NETWORK } from '@chronobank/login/redux/network/actions'
 import contractsManagerDAO from 'dao/ContractsManagerDAO'
 import ProfileModel from 'models/ProfileModel'
-import { push, replace } from 'react-router-redux'
 import { watchStopMarket } from 'redux/market/action'
 import { removeWatchersUserMonitor } from 'redux/ui/actions'
 import { cbeWatcher, watcher } from 'redux/watcher/actions'
@@ -48,7 +47,6 @@ export const logout = () => async (dispatch, getState) => {
     dispatch(removeWatchersUserMonitor())
     await dispatch(watchStopMarket())
     await networkService.destroyNetworkSession(`${window.location.pathname}${window.location.search}`)
-    await dispatch(push('/'))
     if (selectedNetworkId === NETWORK_MAIN_ID) {
       location.reload()
     } else {
@@ -83,7 +81,6 @@ export const login = (account) => async (dispatch, getState) => {
 
   dispatch(watcher())
   isCBE && dispatch(cbeWatcher())
-  dispatch(replace((isCBE && ls.getLastURL()) || defaultURL))
 }
 
 export const bootstrap = (relogin = true) => async (dispatch) => {
--- a/node_modules/@chronobank/src/redux/settings/erc20/tokens/actions.js
+++ b/node_modules/@chronobank/src/redux/settings/erc20/tokens/actions.js
@@ -17,7 +17,6 @@ import { TOKENS_FETCHED, TOKENS_REMOVE, TOKENS_UPDATE } from 'redux/tokens/actio
 import tokenService from 'services/TokenService'
 import Amount from 'models/Amount'
 import ERC20DAO from 'dao/ERC20DAO'
-import { FORM_CBE_TOKEN } from 'components/dialogs/CBETokenDialog/CBETokenDialog'
 
 export const DUCK_SETTINGS_ERC20_TOKENS = 'settingsERC20Tokens'
 
@@ -111,16 +110,5 @@ export const revokeToken = (token: TokenModel | AbstractFetchingModel) => async
 
 export const getDataFromContract = (token) => async (dispatch) => {
   dispatch({ type: TOKENS_FORM_FETCH })
-  if (!address(token.address())) {
-    const dao = new ERC20DAO(token)
-    const symbol = await dao.getSymbolFromContract()
-    const decimals = new BigNumber(await dao.getDecimalsFromContract())
-
-    if (symbol) { // check only the symbol, because token can have decimal values of 0
-      dispatch(change(FORM_CBE_TOKEN, 'symbol', symbol))
-      dispatch(change(FORM_CBE_TOKEN, 'decimals', decimals))
-    }
-
-  }
   dispatch({ type: TOKENS_FORM_FETCH, end: true })
 }
--- a/node_modules/@chronobank/src/redux/wallet/actions.js
+++ b/node_modules/@chronobank/src/redux/wallet/actions.js
@@ -4,11 +4,15 @@
  */
 
 import { DUCK_MAIN_WALLET } from 'redux/mainWallet/actions'
-import { DUCK_MULTISIG_WALLET, selectMultisigWallet } from 'redux/multisigWallet/actions'
+import {
+  DUCK_MULTISIG_WALLET,
+  selectMultisigWallet,
+} from 'redux/multisigWallet/actions'
 
 export const DUCK_WALLET = 'wallet'
 
 export const WALLET_SWITCH_WALLET = 'WALLET/switch_wallet'
+export const WALLET_SELECT_WALLET = 'WALLET/select_wallet'
 
 export const switchWallet = (wallet) => (dispatch) => {
   const isMultisig = wallet.isMultisig()
@@ -26,3 +30,11 @@ export const getCurrentWallet = (state) => {
     ? state.get(DUCK_MULTISIG_WALLET).selected()
     : state.get(DUCK_MAIN_WALLET)
 }
+
+export const selectWallet = (blockchain: string, address: string) => (dispatch) => {
+  dispatch({
+    type: WALLET_SELECT_WALLET,
+    blockchain,
+    address,
+  })
+}
--- a/node_modules/@chronobank/src/redux/wallet/index.js
+++ b/node_modules/@chronobank/src/redux/wallet/index.js
@@ -3,6 +3,6 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-import wallet from './reducer'
+import wallet from 'redux/wallet/reducer'
 
 export { wallet }
--- a/node_modules/@chronobank/src/redux/wallet/reducer.js
+++ b/node_modules/@chronobank/src/redux/wallet/reducer.js
@@ -3,10 +3,12 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-import * as a from './actions'
+import * as a from 'redux/wallet/actions'
 
 const initialState = {
   isMultisig: false,
+  address: null,
+  blockchain: null,
 }
 
 export default (state = initialState, action) => {
@@ -15,6 +17,14 @@ export default (state = initialState, action) => {
       return {
         ...state,
         isMultisig: action.isMultisig,
+        address: action.address || null,
+        blockchain: action.blockchain,
+      }
+    case a.WALLET_SELECT_WALLET:
+      return {
+        ...state,
+        blockchain: action.blockchain,
+        address: action.address,
       }
     default:
       return state
--- a/node_modules/@chronobank/src/redux/wallet/selectors.js
+++ b/node_modules/@chronobank/src/redux/wallet/selectors.js
@@ -3,9 +3,22 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-import { createSelector } from 'reselect'
+/* @flow */
+
+import {
+  createSelector,
+} from 'reselect'
+import { DUCK_MAIN_WALLET } from 'redux/mainWallet/actions'
+import { DUCK_MARKET } from 'redux/market/action'
+import { DUCK_TOKENS } from 'redux/tokens/actions'
+
 import { getCurrentWallet } from './actions'
 
+/**
+ * SIMPLE SELECTORS
+ * ==============================================================================
+ */
+
 export const getMainWallet = (state) => {
   return state.get('mainWallet')
 }
@@ -19,3 +32,189 @@ export const getCurrentWalletBalance = (symbol) => createSelector(
   [ getCurrentWallet ],
   (currentWallet) => currentWallet.balances().item(symbol)
 )
+
+export const selectMainWalletBalancesListStore = (state) =>
+  state.get(DUCK_MAIN_WALLET).balances().list() // BalancesCollection, array of BalanceModel
+
+export const selectMainWalletTokensStore = (state) =>
+  state.get(DUCK_TOKENS) // TokensCollection, array of TokenModel
+
+export const selectMainWalletAddressesListStore = (state) =>
+  state.get(DUCK_MAIN_WALLET).addresses().list() // This is an instance of MainWalletModel
+
+export const selectMarketPricesListStore = (state) => state.get(DUCK_MARKET).prices
+export const selectMarketPricesSelectedCurrencyStore = (state) => state.get(DUCK_MARKET).selectedCurrency
+
+/**
+ * WALLET SECTIONS
+ * 
+ *  Usage example:
+ * 
+ * 
+ * const getSectionedWallets = makeGetSectionedWallets()
+ *   const mapStateToProps = (state, props) => {
+ *     const makeMapStateToProps = () => {
+ *     return {
+ *       walletsSections: getSectionedWallets(state, props),
+ *     }
+ *   }
+ *  return mapStateToProps
+ * }
+ * 
+ * @connect(makeMapStateToProps)
+ * export default class AnyComponent extends PureComponent {
+ */
+
+/**
+ * This is memoized selector. Produce the list of blockchain sections and wallets
+ * 
+ * @return { [{title: string, data: string | string[]}] }
+ *         Returns list of sections for the ReactNative SectionList.
+ */
+export const getMainWalletSections = createSelector(
+  [
+    selectMainWalletAddressesListStore,
+  ],
+  (mainWalletAddressesList) => {
+    return mainWalletAddressesList
+      .filter( (address) => address.address() !== null ) // We do not need wallets with null address (e.g. BTG in Rinkeby/Infura)
+      .reduce( (accumulator, addressModel, blockchain) => {
+        const address = addressModel.address() // AddressModel.address() returns string with wallet's address
+        accumulator.push({
+          // data must contains an array (requirement of SectionList component in React Native, sorry)
+          data: [address],
+          title: blockchain,
+        })
+        return accumulator
+      }, [] )
+      .sort( ({ title: a }, { title: b }) => (a > b) - (a < b) ) // sort by blocakchains titles
+  }
+)
+
+/**
+ * This is the factory for selector
+ * It may be used in different components and each of them will have its own memoized copy
+ * 
+ * @return { [{title: string, data: string | string[]}] }
+ *         Returns list of sections for the ReactNative SectionList.
+ */
+export const makeGetSectionedWallets = () => createSelector(
+  [
+    getMainWalletSections,
+  ],
+  (mainWalletSections) => mainWalletSections
+)
+
+/**
+ * TOKENS AND BALANCE BY ADDRESS
+ * 
+ * Usage example:
+ * const makeMapStateToProps = (origState, origProps) => {
+ *  const getWalletTokensAndBalanceByAddress = makeGetWalletTokensAndBalanceByAddress()
+ *  const mapStateToProps = (state, ownProps) => {
+ *     const walletTokensAndBalanceData = getWalletTokensAndBalanceByAddress(state, ownProps)
+ *     return {
+ *       walletTokensAndBalance: walletTokensAndBalanceData,
+ *     }
+ *   }
+ *   return mapStateToProps
+ * }
+ * 
+ * @connect(makeMapStateToProps)
+ * export default class AnyComponent extends PureComponent<WalletPanelProps> {
+ * 
+ * NOTE: component AnyComnnect MUST have props walletAddress: string & blockchain: string
+ * Both props are required, because we may have same wallet addresses in "Bitcoin" and "Bitcoin Cash" blockchains
+ */
+
+/**
+ * This is the factory for selector
+ * It may be used in different components and each of them will have its own memoized copy
+ * 
+ * @return { { balance: number, tokens: [ {ETH: number } ] } }
+ *         Returns list of sections for the ReactNative SectionList.
+ */
+export const makeGetWalletTokensAndBalanceByAddress = (blockchain) => {
+  return createSelector(
+    [
+      getMainWalletSections,
+      selectMainWalletAddressesListStore,
+      selectMainWalletBalancesListStore,
+      selectMainWalletTokensStore,
+      selectMarketPricesListStore,
+      selectMarketPricesSelectedCurrencyStore,
+    ],
+    (
+      addressesAndBlockchains,
+      mainWalletAddressesList,
+      mainWalletBalances,
+      mainWalletTokens,
+      prices,
+      selectedCurrency,
+    ) => {
+
+      /**
+       * Internal utility
+       * @private
+       */
+      const convertAmountToNumber = (symbol, amount) =>
+        mainWalletTokens
+          .item(symbol)
+          .removeDecimals(amount)
+          .toNumber()
+
+      const walletTokensAndBalanceByAddress = mainWalletBalances // BalancesCollection, array of BalanceModel
+        .filter( (balanceItem) => {
+          const bSymbol = balanceItem.symbol()
+          const bToken = mainWalletTokens.item(bSymbol)
+          return bToken.blockchain() === blockchain
+        })
+        .map( (balance) => {
+          const bAmount = balance.amount()
+          const bSymbol = balance.symbol()
+          const tAmount = convertAmountToNumber(bSymbol, bAmount)
+          let tokenAmountKeyValuePair = {}
+          tokenAmountKeyValuePair[bSymbol] = tAmount
+          return {
+            symbol: bSymbol,
+            amount: tAmount,
+          }
+        })
+
+      const arrWalletTokensAndBalanceByAddress = [...walletTokensAndBalanceByAddress.values()]
+      const result = arrWalletTokensAndBalanceByAddress
+        .reduce( (accumulator, tokenKeyValuePair) => {
+          const { amount, symbol } = tokenKeyValuePair
+          const tokenPrice = prices[ symbol ] && prices[ symbol ][ selectedCurrency ] || null
+          if (tokenPrice && amount > 0) {
+            accumulator.balance += ( amount * tokenPrice )
+          }
+          accumulator.tokens.push({ 
+            [ symbol ]: {
+              amount: amount,
+              balance: amount * (tokenPrice || 0),
+            },
+          })
+          accumulator.tokens = accumulator.tokens.sort( (a, b) => {
+            const oA = Object.keys(a)[0]
+            const oB = Object.keys(b)[0]
+            return (oA > oB) - (oA < oB)
+          } ) // sort by blocakchains titles (TODO: it does not effective to resort whole array each time in reduce, need better place...)
+          return accumulator
+        }, {
+          balance: 0,
+          tokens: [],
+        })
+
+      // Let's add an address of Main Wallet into final result
+      const currentWallet = addressesAndBlockchains
+        .find((mainWalletAddrAndChain) => {
+          return mainWalletAddrAndChain.title === blockchain
+        })
+      result.address = currentWallet && currentWallet.data && currentWallet.data[0]
+
+      return result
+    }
+  )
+}
+
--- a/node_modules/@chronobank/src/redux/watcher/actions.js
+++ b/node_modules/@chronobank/src/redux/watcher/actions.js
@@ -3,23 +3,24 @@
  * Licensed under the AGPL Version 3 license.
  */
 
-import { watchInitMonitor } from '@chronobank/login/redux/monitor/actions'
-import AbstractContractDAO, { TX_FRONTEND_ERROR_CODES } from 'dao/AbstractContractDAO'
-import TransactionErrorNoticeModel from 'models/notices/TransactionErrorNoticeModel'
-import TxError from 'models/TxError'
-import type TxExecModel from 'models/TxExecModel'
-import { watchInitTokens, watchPlatformManager } from 'redux/assetsManager/actions'
-import { watchInitLOC } from 'redux/locs/actions'
 import { initMainWallet } from 'redux/mainWallet/actions'
-import { watchInitMarket } from 'redux/market/action'
-import { notify } from 'redux/notifier/actions'
-import { watchInitOperations } from 'redux/operations/actions'
-import { watchInitERC20Tokens } from 'redux/settings/erc20/tokens/actions'
-import { watchInitCBE } from 'redux/settings/user/cbe/actions'
+import { initMultisigWalletManager } from 'redux/multisigWallet/actions'
 import { initTokens } from 'redux/tokens/actions'
+import { notify } from 'redux/notifier/actions'
 import { showConfirmTxModal, watchInitUserMonitor } from 'redux/ui/actions'
+import { watchInitCBE } from 'redux/settings/user/cbe/actions'
+import { watchInitERC20Tokens } from 'redux/settings/erc20/tokens/actions'
+import { watchInitLOC } from 'redux/locs/actions'
+import { watchInitMarket } from 'redux/market/action'
+import { watchInitMonitor } from '@chronobank/login/redux/monitor/actions'
+import { watchInitOperations } from 'redux/operations/actions'
 import { watchInitPolls } from 'redux/voting/actions'
 import { watchInitProfile } from 'redux/session/actions'
+import { watchInitTokens, watchPlatformManager } from 'redux/assetsManager/actions'
+import AbstractContractDAO, { TX_FRONTEND_ERROR_CODES } from 'dao/AbstractContractDAO'
+import TransactionErrorNoticeModel from 'models/notices/TransactionErrorNoticeModel'
+import TxError from 'models/TxError'
+import type TxExecModel from 'models/TxExecModel'
 
 export const DUCK_WATCHER = 'watcher'
 
@@ -76,6 +77,7 @@ export const watcher = () => async (dispatch) => {
   dispatch(watchInitProfile())
   dispatch(initTokens())
   dispatch(initMainWallet())
+  dispatch(initMultisigWalletManager())
   dispatch(watchPlatformManager())
   dispatch(watchInitTokens())
   dispatch(watchInitMonitor())
